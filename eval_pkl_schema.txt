"""
j: number of speed evaluations
n: number of 8 milisecond timesteps that were recorded
k: number of joints
time and command time are slightly different, command time has possibly higher resolution or more rounding errors. time has nanosecond resolution..
"""


evaluation_recording = {
    'name': "<--name_arg>"
    'joint_recordings': [ j*
        {
            'name'              : [k* joint_names]
            'position_series'   : [n*[k* joint_positions]]
            'velocity_series'   : [n*[k* joint_velocities]]
            'effort_series'     : [n*[k* joint_efforts]]
            'time_nano_series'  : [n* sim_nanos]
            'time_sec_series'   : [n* sim_secs]
            'start_time'        : command_time_of_start_of_speed_trial
            'sim_time_series'   : [n* sim.get_time() interface, also used by command time]
            'command_sec_series': [n* command_time_secs (since start of speed trial)]
            'command_x_series'  : [n* command_x_velocities]
            'command_x_speed'   : command_speed (x direction)

            'walk_phase'        : [n* 0 to 1],
            'support_state'     : [n* phase(0 to 2)],
            'imu_linear_acc_x'  : [n* imu linear acceleration],
            'imu_linear_acc_y'  : [n* up/down direction?],
            'imu_linear_acc_z'  : [n* ..],
            'imu_angular_vel_x' : [n* ..],
            'imu_angular_vel_y' : [n* ..],
            'imu_angular_vel_z' : [n* ..],


            'robot_pose_x': [n* simulator x position],
            'robot_pose_y': [n* simulator y position],
            'robot_pose_z': [n* simulator z position],
            'robot_pose_r': [n* simulator roll],
            'robot_pose_p': [n* simulator pitch],
            'robot_pose_y': [n* simulator yaw],

        }
    ]
    'speeds':[ j*
        {
            'command_x_speed'   : same as in joint recordings
            'actual_speed':     : distance change in command direction over 7.5 seconds
            'speed_factor'      : actual_speed/command_speed
        }
    ]
}


# runs are aquired via Recording(..).get_run(i)
run = {
    'run_name': "<--name_arg>"
    'name'                  : [k* joint_names]
    'position_series'       : [n*[k* joint_positions]]
    'velocity_series'       : [n*[k* joint_velocities]]
    'effort_series'         : [n*[k* joint_efforts]]
    'all_position_series'   : [n*[abs_all_joint_positions]]
    'all_velocity_series'   : [n*[abs_all_joint_velocities]]
    'all_effort_series'     : [n*[abs_all_joint_efforts]]
    'time_nano_series'      : [n* sim_nanos]
    'time_sec_series'       : [n* sim_secs]
    'start_time'            : command_time_of_start_of_speed_trial
    'sim_time_series'       : [n* sim.get_time() interface, also used by command time]
    'command_sec_series'    : [n* command_time_secs (since start of speed trial)]
    'command_x_series'      : [n* command_x_velocities]
    'command_x_speed'       : command_speed (x direction)
    'command_x_speed'       : same as in joint recordings
    'actual_speed':         : distance change in command direction over 7.5 seconds
    'speed_factor'          : actual_speed/command_speed

    'walk_phase'        : [n* 0 to 1],
    'support_state'     : [n* phase(0 to 2)],
    'imu_linear_acc_x'  : [n* imu linear acceleration],
    'imu_linear_acc_y'  : [n* up/down direction?],
    'imu_linear_acc_z'  : [n* ..],
    'imu_angular_vel_x' : [n* ..],
    'imu_angular_vel_y' : [n* ..],
    'imu_angular_vel_z' : [n* ..],
    'robot_pose_x': [n* simulator x position],
    'robot_pose_y': [n* simulator y position],
    'robot_pose_z': [n* simulator z position],
    'robot_pose_r': [n* simulator roll],
    'robot_pose_p': [n* simulator pitch],
    'robot_pose_y': [n* simulator yaw],
}

